<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        font-family: sans-serif;
      }

      .lists {
        display: flex;
      }

      ul {
        background-color: #ccc;
        padding: 2rem;
        margin: 2rem;
      }

      h1 {
        font-family: monospace;
        margin-left: 2rem;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"
      integrity="sha512-0zGLOFv/+OQ6YfVCSGDQWhrDRx0ONmBqWvs3gI4olm8i6xtKoG1FhEnB4eTaWCVnojyfUDgE8Izeln+mAJAkFA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script src="https://cdn.jsdelivr.net/npm/webmidi@latest/dist/iife/webmidi.iife.js"></script>

    <script>
      let data;
      let kick, snare, hat, clap, melody, tiny;
      let commitIndex = 0;
      let currentCommit;
      let authors = [];
      let filesList = [];
      // const shaLabel = document.getElementById("sha-label");
      // const authorsList = document.getElementById("authors-list");
      // const statsLabel = document.getElementById("stats-label");
      // const filesListElement = document.getElementById("files-list");

      const scale = ["d4", "f4", "g4", "a4", "c4"];

      function randInt(min, max) {
        const minCeiled = Math.ceil(min);
        const maxFloored = Math.floor(max);
        return Math.floor(
          Math.random() * (maxFloored - minCeiled + 1) + minCeiled
        ); // The maximum is inclusive and the minimum is inclusive
      }

      const init = async () => {
        const resp = await fetch("./out/out.json");
        data = await resp.json();

        console.log("data loaded");

        WebMidi.enable()
          .then(onEnabled)
          .catch((err) => console.error(err));
      };

      const nextCommit = () => {
        if (commitIndex > data.commits.length - 1) return;
        const commit = data.commits[commitIndex];
        commitIndex++;

        const { sha, author, fileCount, adds, rems, date, files } = commit;
        const paths = files.map((f) => f.path);

        if (date !== null && !authors.find((a) => a.author === author)) {
          authors.push({ author, hits: 1 });
          authorTiles.push({ author, selected: false });

          melody.playNote(randInt(30, 70));
        }

        if (!!date && files?.length > 0) {
          files.forEach((file) => {
            if (!filesList.find((f) => f.path === file.path)) {
              filesList.push({ path: file.path, hits: 1 });
              fileTiles.push({ file, path: file.path, selected: false });
            }
          });
        }

        let stop = false;
        let big = false;
        if (fileCount < 2) {
          Math.random() > 0.5 && tiny.playNote("c4");
          stop = true;
        } else if (fileCount < 4) {
          hat.playNote("c4");
        } else if (fileCount > 10) {
          hat.playNote("c4");
          kick.playNote("c4");
          clap.playNote("c4");
          big = true;
        } else if (adds > rems) {
          kick.playNote("c4");
        } else {
          snare.playNote("c4");
        }

        if (!stop) {
          currentCommit = commit;

          authors = authors.map((a) => {
            return a.author === author ? { ...a, hits: a.hits + 1 } : a;
          });

          filesList = filesList.map((f) => {
            const hit = paths.includes(f.path);
            return hit ? { ...f, hits: f.hits + 1 } : f;
          });

          authorTiles = authorTiles.map((item) => {
            return item.author === author
              ? { ...item, selected: true }
              : { ...item, selected: false };
          });

          fileTiles = fileTiles.map((item) => {
            return paths.includes(item.path)
              ? { ...item, selected: true }
              : { ...item, selected: false };
          });
        }

        setTimeout(nextCommit, big ? 70 * fileCount * 0.2 : 70);
      };

      function onEnabled() {
        console.log("MIDI enabled");
        console.log(WebMidi.outputs); //  WebMidi.outputs.forEach((o) => console.log(o.name));

        const device = WebMidi.outputs.find(
          (output) => output.name === "Elektron Syntakt"
        );

        kick = device.channels[1];
        snare = device.channels[2];
        clap = device.channels[3];
        hat = device.channels[4];
        melody = device.channels[5];
        tiny = device.channels[6];

        console.log("MIDI initialized");

        setTimeout(nextCommit, 80);
      }

      init();

      let WIDTH = 2400;
      let HEIGHT = 1200;

      let authorTiles = [];
      let fileTiles = [];

      const cellSize = WIDTH * 0.008;
      const totalCols = WIDTH / cellSize;
      const roundness = 3;

      const authorItemsPerRow = totalCols * 0.2;
      const size = cellSize * 0.8;
      const fileItemsPerRow = totalCols * 0.79;

      let backgroundColor;
      let foregroundColor;
      let selectedColor;

      function setup() {
        backgroundColor = color(0, 0, 0, 10);
        foregroundColor = color(100, 100, 100);
        selectedColor = color(255, 255, 255);
        unselectedColor = foregroundColor;
        createCanvas(WIDTH, HEIGHT);
      }

      function draw() {
        background(backgroundColor);

        let authorCellCount = 0;
        let authorRowNum = 0;
        let fileCellCount = 0;
        let fileRowNum = 0;

        const selectedFileTiles = [];
        let selectedAuthorTile = {};

        fileTiles.forEach((item) => {
          const x = fileCellCount * cellSize;
          const y = HEIGHT - fileRowNum * cellSize - cellSize;
          const lookup = filesList.find((f) => f.path === item.path);
          const op = lookup.hits * 0.15 + 5;

          strokeWeight(0);
          // stroke(foregroundColor);
          fill(
            item.selected
              ? selectedColor
              : color(
                  Math.max(0, 255 - op),
                  Math.max(0, 255 - op),
                  255,
                  Math.min(200, Math.ceil(op))
                )
          );
          rect(
            x + (cellSize - size) / 2,
            y + (cellSize - size) / 2,
            size,
            size,
            roundness
          );

          if (item.selected) {
            selectedFileTiles.push({
              x: x + (cellSize - size) / 2 + size / 2,
              y: y + (cellSize - size) / 2 + size / 2,
            });
          }

          fileCellCount++;

          if (fileCellCount >= fileItemsPerRow) {
            fileRowNum++;
            fileCellCount = 0;
          }
        });

        authorTiles.forEach((item) => {
          const x = WIDTH - authorCellCount * cellSize - cellSize;
          const y = authorRowNum * cellSize + 0;
          const lookup = authors.find((a) => a.author === item.author);
          // console.log(lookup.author, lookup.hits);
          strokeWeight(0);

          const op = lookup.hits * 0.15 + 5;

          // stroke(0);
          fill(
            item.selected
              ? selectedColor
              : color(
                  Math.max(0, 255 - op),
                  Math.max(0, 255 - op),
                  255,
                  Math.min(200, Math.ceil(op))
                )
          );
          rect(
            x + (cellSize - size) / 2,
            y + (cellSize - size) / 2,
            size,
            size,
            roundness
          );

          if (item.selected) {
            selectedAuthorTile = {
              x: x + (cellSize - size) / 2 + size / 2,
              y: y + (cellSize - size) / 2 + size / 2,
            };
          }

          authorCellCount++;

          if (authorCellCount >= authorItemsPerRow) {
            authorRowNum++;
            authorCellCount = 0;
          }
        });

        // console.log(selectedAuthorTile);

        if (selectedFileTiles.length > 0 && selectedAuthorTile) {
          selectedFileTiles.forEach((tile) => {
            strokeWeight(1);
            stroke(foregroundColor);
            line(tile.x, tile.y, selectedAuthorTile.x, selectedAuthorTile.y);
          });
        }

        if (currentCommit) {
          fill(selectedColor);
          stroke(foregroundColor);
          strokeWeight(0);
          // textSize(12);
          textFont("Monaco", 12);
          text(
            `${currentCommit.sha}\n${currentCommit.date}\n${
              currentCommit.author
            }\n+${currentCommit.adds ?? 0} / -${currentCommit.rems ?? 0}\n\n${
              currentCommit.notes ?? ""
            }`,
            20,
            20
          );
        }
      }
    </script>
  </body>
</html>
